Index: src/main/java/it/unipi/dii/inginf/lsdb/justrecipe/persistence/MongoDBDriver.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.unipi.dii.inginf.lsdb.justrecipe.persistence;\n\nimport com.google.gson.Gson;\nimport com.google.gson.reflect.TypeToken;\nimport com.mongodb.ConnectionString;\nimport com.mongodb.MongoClientSettings;\nimport com.mongodb.client.*;\nimport com.mongodb.client.model.Accumulators;\nimport com.mongodb.client.model.Aggregates;\nimport com.mongodb.client.model.Filters;\nimport com.mongodb.client.model.Sorts;\nimport it.unipi.dii.inginf.lsdb.justrecipe.config.ConfigurationParameters;\nimport it.unipi.dii.inginf.lsdb.justrecipe.model.*;\nimport it.unipi.dii.inginf.lsdb.justrecipe.utils.Utils;\nimport org.bson.Document;\nimport org.bson.codecs.configuration.CodecRegistry;\nimport org.bson.codecs.pojo.PojoCodecProvider;\nimport org.bson.conversions.Bson;\nimport java.lang.reflect.Type;\nimport java.util.*;\nimport java.util.function.Consumer;\nimport java.util.regex.Pattern;\n\nimport static com.mongodb.client.model.Aggregates.*;\nimport static com.mongodb.client.model.Filters.eq;\nimport static com.mongodb.client.model.Projections.*;\nimport static com.mongodb.client.model.Projections.include;\nimport static com.mongodb.client.model.Sorts.ascending;\nimport static com.mongodb.client.model.Sorts.descending;\nimport static org.bson.codecs.configuration.CodecRegistries.fromProviders;\nimport static org.bson.codecs.configuration.CodecRegistries.fromRegistries;\n\n/**\n * This class is used to communicate with MongoDB\n */\npublic class MongoDBDriver implements DatabaseDriver{\n    private static MongoDBDriver instance;\n\n    private MongoClient mongoClient;\n    private MongoDatabase database;\n    private MongoCollection collection;\n    private CodecRegistry pojoCodecRegistry;\n    private String ip;\n    private int port;\n    private String username;\n    private String password;\n    private String dbName;\n\n    public static MongoDBDriver getInstance() {\n        if (instance == null)\n        {\n            instance = new MongoDBDriver(Utils.readConfigurationParameters());\n        }\n        return instance;\n    }\n\n    /**\n     * Consumer function that prints the document in json format\n     */\n    private Consumer<Document> printDocuments = doc -> {\n        System.out.println(doc.toJson());\n    };\n\n    private MongoDBDriver (ConfigurationParameters configurationParameters)\n    {\n        this.ip = configurationParameters.getMongoIp();\n        this.port = configurationParameters.getMongoPort();\n        this.username = configurationParameters.getMongoUsername();\n        this.password = configurationParameters.getMongoPassword();\n        this.dbName = configurationParameters.getMongoDbName();\n        initConnection();\n        chooseCollection(\"recipe\");\n    }\n\n    /**\n     * Method that inits the MongoClient and choose the correct database\n     */\n    @Override\n    public void initConnection() {\n        ConnectionString connectionString;\n        if (!username.equals(\"\")) // if there are access rules\n        {\n            connectionString = new ConnectionString(\"mongodb://\" + username + \":\" + password\n                    + \"@\" + ip + \":\" + port);\n        }\n        else // standard access\n        {\n            connectionString = new ConnectionString(\"mongodb://\" + ip + \":\" + port);\n        }\n        mongoClient = MongoClients.create(connectionString);\n        database = mongoClient.getDatabase(dbName);\n        pojoCodecRegistry = fromRegistries(MongoClientSettings.getDefaultCodecRegistry(),\n                fromProviders(PojoCodecProvider.builder().automatic(true).build()));\n    }\n\n    /**\n     * Method used to close the connection\n     */\n    @Override\n    public void closeConnection() {\n        if (mongoClient != null)\n            mongoClient.close();\n    }\n\n    /**\n     * Add a new recipe in MongoDB\n     * @param r The object Recipe which contains all the necessary information about it\n     */\n    public void addRecipe(Recipe r)\n    {\n        Document doc = new Document(\"title\",r.getTitle())\n                .append(\"instructions\",r.getInstructions())\n                .append(\"ingredients\",r.getIngredients());\n        // Optional fields\n        if(!r.getCategories().isEmpty())\n            doc.append(\"categories\",r.getCategories());\n        if(r.getCalories()!=-1)\n            doc.append(\"calories\",r.getCalories());\n        if(r.getFat()!=-1)\n            doc.append(\"fat\",r.getFat());\n        if(r.getProtein()!=-1)\n            doc.append(\"protein\",r.getProtein());\n        if(r.getCarbs()!=-1)\n            doc.append(\"carbs\",r.getCarbs());\n        // Automatic fields\n        doc.append(\"creationTime\",new Date(r.getCreationTime().getTime()))\n                .append(\"authorUsername\",r.getAuthorUsername());\n        // Other option field\n        if(!r.getPicture().isEmpty())\n            doc.append(\"picture\",r.getPicture());\n\n        collection.insertOne(doc);\n    }\n    /**\n     * Method used to change the collection\n     * @param name  name of the new collection\n     */\n    public void chooseCollection(String name)\n    {\n        collection = database.getCollection(name);\n    }\n\n    public List<Recipe> getRecipesFromAuthorUsername(int howManySkip, int howMany, String username){\n        List<Recipe> recipes = new ArrayList<>();\n        Gson gson = new Gson();\n        List<Document> results = new ArrayList<>();\n        Bson sort = sort(descending(\"creationTime\"));\n        Bson skip = skip(howManySkip);\n        Bson limit = limit(howMany);\n        Bson match = match(eq(\"authorUsername\", username));\n        results = (List<Document>) collection.aggregate(Arrays.asList(match, sort, skip, limit))\n                .into(new ArrayList<>());\n        Type recipeListType = new TypeToken<ArrayList<Recipe>>(){}.getType();\n        recipes = gson.fromJson(gson.toJson(results), recipeListType);\n        return recipes;\n    }\n\n    /**\n     * Function that return the recipe given the title\n     * @param title     Title of the recipe\n     * @return          The recipe\n     */\n    public Recipe getRecipeFromTitle(String title){\n        Recipe recipe = null;\n        Gson gson = new Gson();\n        Type recipeType = new TypeToken<Recipe>(){}.getType();\n        Document myDoc =(Document) collection.find(eq(\"title\", title)).first();\n        recipe = gson.fromJson(gson.toJson(myDoc), recipeType);\n        return recipe;\n    }\n\n    /**\n     * Function that returns \"howMany\" recipes that contains in their title the title inserted by the user\n     * @param title         Title to check\n     * @param howManySkip   How many to skip\n     * @param howMany       How many recipe we want obtain\n     * @return              The list of the recipes that match the condition\n     */\n    public List<Recipe> searchRecipesFromTitle (String title, int howManySkip, int howMany)\n    {\n        List<Recipe> recipes = new ArrayList<>();\n        Gson gson = new Gson();\n        Pattern pattern = Pattern.compile(\"^.*\" + title + \".*$\", Pattern.CASE_INSENSITIVE);\n        Bson match = Aggregates.match(Filters.regex(\"title\", pattern));\n        Bson sort = sort(descending(\"creationTime\"));\n        Bson skip = skip(howManySkip);\n        Bson limit = limit(howMany);\n        List<Document> results = (List<Document>) collection.aggregate(Arrays.asList(match, sort, skip, limit))\n                .into(new ArrayList<>());\n        Type recipeListType = new TypeToken<ArrayList<Recipe>>(){}.getType();\n        recipes = gson.fromJson(gson.toJson(results), recipeListType);\n        return recipes;\n    }\n\n    /**\n     * Function that returns a list of recipes that contains the category passed (or one piece of that)\n     * @param category          Category to search\n     * @param howManySkip       How many to skip\n     * @param howMany           How many to obtain\n     * @return                  The list of recipes\n     */\n    public List<Recipe> searchRecipesFromCategory (String category, int howManySkip, int howMany)\n    {\n        List<Recipe> recipes = new ArrayList<>();\n        Gson gson = new Gson();\n        Pattern pattern = Pattern.compile(\"^.*\" + category + \".*$\", Pattern.CASE_INSENSITIVE);\n        Bson match = match(Filters.regex(\"categories\", pattern));\n        Bson sort = sort(descending(\"creationTime\"));\n        Bson skip = skip(howManySkip);\n        Bson limit = limit(howMany);\n        List<Document> results = (List<Document>) collection.aggregate(Arrays.asList(match, sort, skip, limit))\n                .into(new ArrayList<>());\n        Type recipeListType = new TypeToken<ArrayList<Recipe>>(){}.getType();\n        recipes = gson.fromJson(gson.toJson(results), recipeListType);\n        return recipes;\n    }\n\n    /**\n     * Function that return the most common categories (the top one used)\n     * @param howManySkip           How many to skip\n     * @param howManyCategories     How many category to consider in the rank\n     * @return                      The category ordered by the number of recipes in which it is used\n     */\n    public List<String> searchMostCommonRecipeCategories (int howManySkip, int howManyCategories)\n    {\n        List<String> mostCommonCategories = new ArrayList<>();\n        Bson unwind = unwind(\"$categories\");\n        Bson group = group(\"$categories\", Accumulators.sum(\"numberOfRecipes\", 1));\n        Bson project = project(fields(computed(\"categories\", \"$_id\"), excludeId(), include(\"numberOfRecipes\")));\n        Bson sort = sort(descending(\"numberOfRecipes\"));\n        Bson skip = skip(howManySkip);\n        Bson limit = limit(howManyCategories);\n        List<Document> results = (List<Document>)\n                collection.aggregate(Arrays.asList(unwind, group, project, sort, skip, limit)).into(new ArrayList());\n\n        for (Document document: results)\n        {\n            mostCommonCategories.add(document.getString(\"categories\"));\n        }\n        return mostCommonCategories;\n    }\n\n    /**\n     * Function that returns \"howMany\" recipes of one category\n     * @param category      The category to consider\n     * @param howMany       How many recipes to return\n     * @return              List of the recipes\n     */\n    public List<Recipe> getRecipesOfCategory (String category, int howMany)\n    {\n        List<Recipe> recipes = new ArrayList<>();\n        Gson gson = new Gson();\n        Bson match = match(Filters.in(\"categories\", category));\n        Bson sort = sort(descending(\"creationTime\"));\n        Bson limit = limit(howMany);\n        List<Document> results = (List<Document>)\n                collection.aggregate(Arrays.asList(match, sort, limit)).into(new ArrayList());\n        Type recipeListType = new TypeToken<ArrayList<Recipe>>(){}.getType();\n        recipes = gson.fromJson(gson.toJson(results), recipeListType);\n        return recipes;\n    }\n\n    /**\n     * Function for searching all the comments, ordered by the creationTime (first the last)\n     * The list will be useful for the moderators\n     * @param howManySkip   How many to skip\n     * @param howMany       How many comments we want obtain\n     * @return              The list of the comments\n     */\n    public List<Comment> searchAllComments (int howManySkip, int howMany)\n    {\n        List<Comment> comments = new ArrayList<>();\n        Gson gson = new Gson();\n        Bson unwind = unwind(\"$comments\");\n        Bson sort = sort(descending(\"creationTime\"));\n        Bson skip = skip(howManySkip);\n        Bson limit = limit(howMany);\n        MongoCursor<Document> iterator = (MongoCursor<Document>)\n                collection.aggregate(Arrays.asList(unwind, sort, skip, limit)).iterator();\n        while (iterator.hasNext())\n        {\n            Document document = (Document) iterator.next().get(\"comments\");\n            Comment comment = gson.fromJson(gson.toJson(document), Comment.class);\n            comments.add(comment);\n        }\n        return comments;\n    }\n\n    public void updateComments(String title, List<Comment> comments){\n        collection = collection.withCodecRegistry(pojoCodecRegistry);\n        Bson update = new Document(\"comments\", comments);\n        Bson updateOperation = new Document(\"$set\", update);\n        collection.updateOne(new Document(\"title\", title), updateOperation);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/unipi/dii/inginf/lsdb/justrecipe/persistence/MongoDBDriver.java b/src/main/java/it/unipi/dii/inginf/lsdb/justrecipe/persistence/MongoDBDriver.java
--- a/src/main/java/it/unipi/dii/inginf/lsdb/justrecipe/persistence/MongoDBDriver.java	(revision 8bab4c89748eb1a7f8557f9361c3a1ce907e0f69)
+++ b/src/main/java/it/unipi/dii/inginf/lsdb/justrecipe/persistence/MongoDBDriver.java	(date 1608481617883)
@@ -5,10 +5,7 @@
 import com.mongodb.ConnectionString;
 import com.mongodb.MongoClientSettings;
 import com.mongodb.client.*;
-import com.mongodb.client.model.Accumulators;
-import com.mongodb.client.model.Aggregates;
-import com.mongodb.client.model.Filters;
-import com.mongodb.client.model.Sorts;
+import com.mongodb.client.model.*;
 import it.unipi.dii.inginf.lsdb.justrecipe.config.ConfigurationParameters;
 import it.unipi.dii.inginf.lsdb.justrecipe.model.*;
 import it.unipi.dii.inginf.lsdb.justrecipe.utils.Utils;
@@ -292,4 +289,13 @@
         Bson updateOperation = new Document("$set", update);
         collection.updateOne(new Document("title", title), updateOperation);
     }
+
+    public void deleteComment(Comment comment){
+        Bson pull = Updates.pull("comments", comment);
+//        collection.updateOne(, pull);
+    }
+
+    public void addComment(Comment comment, String title){
+
+    }
 }
Index: src/main/java/it/unipi/dii/inginf/lsdb/justrecipe/controller/CommentController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.unipi.dii.inginf.lsdb.justrecipe.controller;\n\nimport it.unipi.dii.inginf.lsdb.justrecipe.model.Comment;\nimport it.unipi.dii.inginf.lsdb.justrecipe.model.Session;\nimport it.unipi.dii.inginf.lsdb.justrecipe.persistence.Neo4jDriver;\nimport it.unipi.dii.inginf.lsdb.justrecipe.utils.Utils;\nimport javafx.fxml.FXML;\nimport javafx.scene.control.Button;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.TextArea;\n\n/**\n * Controller for the single comment\n */\npublic class CommentController {\n\n    @FXML private Label commentDate;\n    @FXML private Label commentUsername;\n    @FXML private TextArea commentTextArea;\n    @FXML private Button commentModifyButton;\n    @FXML private Button commentDeleteButton;\n    @FXML private Button commentSaveButton;\n\n    private Comment comment;\n    private Session appSession;\n\n\n    public void initialize ()\n    {\n        appSession = Session.getInstance();\n    }\n\n    public void setComment(Comment comment) {\n        this.comment = comment;\n        commentDate.setText(\"Written at: \" + Utils.fromDateToString(comment.getCreationTime()));\n        commentUsername.setText(\"By: \" + comment.getAuthorUsername());\n        commentTextArea.setText(comment.getText());\n\n        if((appSession.getLoggedUser().getRole()!=0) || (appSession.getLoggedUser().getUsername().equals(comment.getAuthorUsername())))\n            commentDeleteButton.setOnMouseClicked(mouseEvent -> Neo4jDriver.getInstance().deleteComment(comment.getAuthorUsername(),comment.getCreationTime()));\n        else\n            commentDeleteButton.setVisible(false);\n\n        if(appSession.getLoggedUser().getUsername().equals(comment.getAuthorUsername()))\n            commentModifyButton.setOnMouseClicked(mouseEvent -> Neo4jDriver.getInstance().editComment(comment.getAuthorUsername(),comment.getCreationTime()));\n        else\n            commentModifyButton.setVisible(false);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/unipi/dii/inginf/lsdb/justrecipe/controller/CommentController.java b/src/main/java/it/unipi/dii/inginf/lsdb/justrecipe/controller/CommentController.java
--- a/src/main/java/it/unipi/dii/inginf/lsdb/justrecipe/controller/CommentController.java	(revision 8bab4c89748eb1a7f8557f9361c3a1ce907e0f69)
+++ b/src/main/java/it/unipi/dii/inginf/lsdb/justrecipe/controller/CommentController.java	(date 1608481617900)
@@ -4,10 +4,14 @@
 import it.unipi.dii.inginf.lsdb.justrecipe.model.Session;
 import it.unipi.dii.inginf.lsdb.justrecipe.persistence.Neo4jDriver;
 import it.unipi.dii.inginf.lsdb.justrecipe.utils.Utils;
+import javafx.event.ActionEvent;
 import javafx.fxml.FXML;
+import javafx.scene.AccessibleAction;
 import javafx.scene.control.Button;
 import javafx.scene.control.Label;
 import javafx.scene.control.TextArea;
+import javafx.scene.input.MouseEvent;
+import javafx.scene.layout.VBox;
 
 /**
  * Controller for the single comment
@@ -20,6 +24,7 @@
     @FXML private Button commentModifyButton;
     @FXML private Button commentDeleteButton;
     @FXML private Button commentSaveButton;
+    @FXML private VBox commentVBox;
 
     private Comment comment;
     private Session appSession;
@@ -28,6 +33,16 @@
     public void initialize ()
     {
         appSession = Session.getInstance();
+        commentDeleteButton.setOnAction(mouseEvent -> deleteButtonAction(mouseEvent));
+    }
+
+    public void deleteButtonAction(ActionEvent mouseEvent){
+//        System.out.println(appSession.getLoggedUser().getUsername());
+//        System.out.println(commentUsername.getText().substring(4));
+//        if(appSession.getLoggedUser().getRole() == 1 || appSession.getLoggedUser().getUsername().equals(commentUsername.getText().substring(4)))
+//            System.out.println("devo cancellare il commento in questione!");
+        commentVBox.getChildren().remove(0,commentVBox.getChildren().size());
+
     }
 
     public void setComment(Comment comment) {
Index: src/main/java/it/unipi/dii/inginf/lsdb/justrecipe/controller/RecipePageController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.unipi.dii.inginf.lsdb.justrecipe.controller;\n\nimport it.unipi.dii.inginf.lsdb.justrecipe.model.Comment;\nimport it.unipi.dii.inginf.lsdb.justrecipe.model.Recipe;\nimport it.unipi.dii.inginf.lsdb.justrecipe.model.Session;\nimport it.unipi.dii.inginf.lsdb.justrecipe.persistence.MongoDBDriver;\nimport it.unipi.dii.inginf.lsdb.justrecipe.persistence.Neo4jDriver;\nimport it.unipi.dii.inginf.lsdb.justrecipe.utils.Utils;\nimport javafx.event.ActionEvent;\nimport javafx.fxml.FXML;\nimport javafx.fxml.FXMLLoader;\nimport javafx.geometry.Pos;\nimport javafx.scene.AccessibleAction;\nimport javafx.scene.control.Button;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.TextArea;\nimport javafx.scene.image.Image;\nimport javafx.scene.image.ImageView;\nimport javafx.scene.input.MouseEvent;\nimport javafx.scene.layout.Pane;\nimport javafx.scene.layout.VBox;\nimport javafx.scene.text.Font;\nimport javafx.scene.text.Text;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * Controller for the page of the recipe\n */\npublic class RecipePageController {\n\n    @FXML private ImageView homeImg;\n    @FXML private ImageView discoveryImg;\n    @FXML private ImageView profileImg;\n    @FXML private Text recipeInstructions;\n    @FXML private ImageView recipeLikeImg;\n    @FXML private ImageView recipePicture;\n    @FXML private ImageView logoutPic;\n    @FXML private Text recipeTitle;\n    @FXML private Text recipeUsername;\n    @FXML private Text recipeCarbs;\n    @FXML private Text recipeCalories;\n    @FXML private Text recipeFat;\n    @FXML private ImageView recipeEditImg;\n    @FXML private Text recipeCategories;\n    @FXML private Text recipeIngredients;\n    @FXML private Text recipeProtein;\n    @FXML private Label recipeLikes;\n    @FXML private Label recipeDate;\n    @FXML private VBox recipeVBox;\n    @FXML private ImageView recipeDelete;\n    @FXML private TextArea commentsArea;\n    @FXML private Button sendButton;\n    @FXML private Button cancelButton;\n\n    private Recipe recipe;\n    private Session appSession;\n    private Neo4jDriver neo4jDriver;\n    private MongoDBDriver mongoDBDriver;\n\n    public void initialize ()\n    {\n        homeImg.setOnMouseClicked(mouseEvent -> clickOnHomepageToChangePage(mouseEvent));\n        profileImg.setOnMouseClicked(mouseEvent -> clickOnProfileToChangePage(mouseEvent));\n        discoveryImg.setOnMouseClicked(mouseEvent -> clickOnDiscoveryToChangePage(mouseEvent));\n        logoutPic.setOnMouseClicked(mouseEvent -> clickOnLogoutImg(mouseEvent));\n        recipeVBox.setAlignment(Pos.CENTER);\n        appSession = Session.getInstance();\n        neo4jDriver = Neo4jDriver.getInstance();\n        mongoDBDriver = MongoDBDriver.getInstance();\n        sendButton.setOnAction(actionEvent -> handleSendButtonAction(actionEvent));\n        cancelButton.setOnAction(actionEvent -> handleCancelButtonAction(actionEvent));\n        recipeLikeImg.setOnMouseClicked(mouseEvent -> handleClickOnLike());\n    }\n\n    private void handleClickOnLike()\n    {\n        if(neo4jDriver.isThisRecipeLikedByOne(recipeTitle.getText(),appSession.getLoggedUser().getUsername()))\n        {\n            neo4jDriver.unlike(appSession.getLoggedUser().getUsername(),recipeTitle.getText());\n            recipeLikeImg.setImage(new Image(\"img/like.png\"));\n        }\n        else\n        {\n            neo4jDriver.like(appSession.getLoggedUser().getUsername(),recipeTitle.getText());\n            recipeLikeImg.setImage(new Image(\"img/alreadyliked.png\"));\n        }\n\n        recipeLikes.setText(String.valueOf(neo4jDriver.howManyLikes(recipeTitle.getText())));\n    }\n\n    /**\n     * Function who handle the adding comments, and upload on mongoDB\n     * @param actionEvent pressing the button\n     */\n    private void handleSendButtonAction(ActionEvent actionEvent){\n        if(commentsArea.getText().equals(\"\")) {\n            Utils.showErrorAlert(\"No Comments in the CommentsArea\");\n            return;\n        }\n//        System.out.println(recipe.getComments());\n//        System.out.println(recipe.getTitle());\n        Comment comment = new Comment(appSession.getLoggedUser().getUsername(), commentsArea.getText(), new Date());\n        if(recipe.getComments() != null)\n            recipe.addComments(comment);\n        else{\n            List<Comment> comments= new ArrayList<>();\n            comments.add(comment);\n            recipe.setComments(comments);\n        }\n        Utils.showComment(recipeVBox, comment);\n//        System.out.println(recipe.getComments());\n        mongoDBDriver.updateComments(recipe.getTitle(), recipe.getComments());\n    }\n\n    /**\n     * Cancelling the comment textArea by clicking on the cancel Button\n     * @param actionEvent pressing the button\n     */\n    private void handleCancelButtonAction(ActionEvent actionEvent){\n        if(!commentsArea.getText().equals(\"\")) commentsArea.setText(\"\");\n    }\n\n    /**\n     * Setters for the recipe, in which we also set the correct value to show\n     * @param r    Recipe to show\n     */\n    public void setRecipe(Recipe r) {\n        String title = r.getTitle();\n        if(r.getInstructions() == null){\n            System.out.println(\"Snap from Neo ---> getting recipes from MongoDB!\");                                     //DEBUG\n            Recipe recipeMongoDB = MongoDBDriver.getInstance().getRecipeFromTitle(title);\n            this.recipe = recipeMongoDB;\n        }else\n            this.recipe = r;\n        recipeTitle.setText(recipe.getTitle());\n        recipeInstructions.setText(recipe.getInstructions());\n        if (recipe.getPicture() != null)\n        {\n            recipePicture.setImage(new Image(recipe.getPicture()));\n        }\n        else\n        {\n            recipePicture.setImage(new Image(\"img/genericRecipe.png\"));\n        }\n        recipeUsername.setText(recipe.getAuthorUsername());\n        recipeCarbs.setText(String.valueOf(recipe.getCarbs()));\n        recipeCalories.setText(String.valueOf(recipe.getCalories()));\n        recipeFat.setText(String.valueOf(recipe.getFat()));\n        recipeProtein.setText(String.valueOf(recipe.getProtein()));\n        recipeCategories.setText(Utils.fromListToString(recipe.getCategories()));\n        recipeIngredients.setText(Utils.fromListToString(recipe.getIngredients()));\n        recipeDate.setText(\"Published on: \" + Utils.fromDateToString(recipe.getCreationTime()));\n        //TO DO\n        recipeLikes.setText(String.valueOf(neo4jDriver.howManyLikes(recipe.getTitle())));\n        if(neo4jDriver.isThisRecipeLikedByOne(recipe.getTitle(),appSession.getLoggedUser().getUsername()))\n            recipeLikeImg.setImage(new Image(\"img/alreadyliked.png\"));\n        \n        if(recipe.getComments() != null) {\n            Label commentsTitle = new Label(\"Comments:\");\n            commentsTitle.setFont(Font.font(24));\n            recipeVBox.getChildren().add(commentsTitle);\n            Utils.showComments(recipeVBox, recipe.getComments());\n        }\n//        List<Comment> comments = new ArrayList<>();\n//        comments.add(new Comment(\"Pippo\", \"Hello World!\", new Date()));\n//        comments.add(new Comment(\"Pluto\", \"Fantastic recipe!\", new Date()));\n//        recipe.setComments(comments);\n//        if (comments != null)\n//        {\n//            Label commentsTitle = new Label(\"Comments:\");\n//            commentsTitle.setFont(Font.font(24));\n//            recipeVBox.getChildren().add(commentsTitle);\n//            Utils.showComments(recipeVBox, recipe.getComments());\n//        }\n\n        if(appSession.getLoggedUser().getRole()!=2 && !appSession.getLoggedUser().getUsername().equals(recipe.getAuthorUsername()))\n            recipeDelete.setVisible(false);\n        else\n            recipeDelete.setOnMouseClicked(mouseEvent -> neo4jDriver.deleteRecipe(recipe.getTitle(),recipe.getCreationTime()));\n    }\n\n    /**\n     * Function used to handle the click on the homepage icon\n     * @param mouseEvent    event that represents the click on the icon\n     */\n    private void clickOnHomepageToChangePage(MouseEvent mouseEvent){\n        HomePageController homePageController = (HomePageController)\n                Utils.changeScene(\"/homepage.fxml\", mouseEvent);\n    }\n\n    /**\n     * Function used to handle the click on the profile icon\n     * @param mouseEvent    event that represents the click on the icon\n     */\n    private void clickOnProfileToChangePage(MouseEvent mouseEvent){\n        ProfilePageController profilePageController = (ProfilePageController)\n                Utils.changeScene(\"/profilePage.fxml\", mouseEvent);\n        profilePageController.setProfile(Session.getInstance().getLoggedUser());\n    }\n\n    /**\n     * Function used to handle the click on the discovery icon\n     * @param mouseEvent    event that represents the click on the icon\n     */\n    private void clickOnDiscoveryToChangePage(MouseEvent mouseEvent){\n        DiscoveryPageController discoveryPageController = (DiscoveryPageController)\n                Utils.changeScene(\"/discoveryPage.fxml\", mouseEvent);\n    }\n\n    /**\n     * Function that let the logout action, by going into the welcome page\n     * @param mouseEvent event that represents the click on the icon\n     */\n    private void clickOnLogoutImg(MouseEvent mouseEvent){\n        try {\n            WelcomePageController welcomePageController = (WelcomePageController)\n                    Utils.changeScene(\"/welcome.fxml\", mouseEvent);\n        }catch (NullPointerException n){System.out.println(\"profilePageController is null!!!!\");}\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/it/unipi/dii/inginf/lsdb/justrecipe/controller/RecipePageController.java b/src/main/java/it/unipi/dii/inginf/lsdb/justrecipe/controller/RecipePageController.java
--- a/src/main/java/it/unipi/dii/inginf/lsdb/justrecipe/controller/RecipePageController.java	(revision 8bab4c89748eb1a7f8557f9361c3a1ce907e0f69)
+++ b/src/main/java/it/unipi/dii/inginf/lsdb/justrecipe/controller/RecipePageController.java	(date 1608481617907)
@@ -114,7 +114,8 @@
         }
         Utils.showComment(recipeVBox, comment);
 //        System.out.println(recipe.getComments());
-        mongoDBDriver.updateComments(recipe.getTitle(), recipe.getComments());
+        mongoDBDriver.addComment(comment, recipe.getTitle());
+//        mongoDBDriver.updateComments(recipe.getTitle(), recipe.getComments());
     }
 
     /**
Index: src/main/resources/comment.fxml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<?import javafx.geometry.Insets?>\n<?import javafx.scene.control.Button?>\n<?import javafx.scene.control.Label?>\n<?import javafx.scene.control.TextArea?>\n<?import javafx.scene.layout.AnchorPane?>\n<?import javafx.scene.layout.Pane?>\n<?import javafx.scene.layout.VBox?>\n\n<VBox maxHeight=\"-Infinity\" maxWidth=\"-Infinity\" minHeight=\"-Infinity\" minWidth=\"-Infinity\" prefWidth=\"600.0\" style=\"-fx-border-color: orange; -fx-border-radius: 10px; -fx-background-position: center; -fx-border-style: solid; -fx-border-image-width: 3px; -fx-background-color: white;\" xmlns=\"http://javafx.com/javafx/11.0.1\" xmlns:fx=\"http://javafx.com/fxml/1\" fx:controller=\"it.unipi.dii.inginf.lsdb.justrecipe.controller.CommentController\">\n   <children>\n      <AnchorPane prefHeight=\"41.0\" prefWidth=\"600.0\" VBox.vgrow=\"ALWAYS\">\n         <children>\n            <Label fx:id=\"commentDate\" layoutX=\"26.0\" layoutY=\"12.0\" text=\"Written at: Tue Feb 25 17:11:26 \" />\n            <Label fx:id=\"commentUsername\" alignment=\"CENTER_RIGHT\" layoutX=\"456.0\" layoutY=\"12.0\" text=\"By: Username\" textAlignment=\"RIGHT\" />\n         </children>\n         <VBox.margin>\n            <Insets />\n         </VBox.margin>\n      </AnchorPane>\n      <Pane prefWidth=\"200.0\" VBox.vgrow=\"ALWAYS\">\n         <children>\n            <TextArea fx:id=\"commentTextArea\" layoutX=\"26.0\" layoutY=\"7.0\" prefHeight=\"89.0\" prefWidth=\"547.0\" style=\"-fx-focus-color: orange;\" text=\"Lorem ipsum dolor sit amet, consectetur adipiscing elit.&#10; \" wrapText=\"true\" />\n         </children>\n      </Pane>\n      <AnchorPane prefHeight=\"69.0\" prefWidth=\"600.0\" VBox.vgrow=\"ALWAYS\">\n         <children>\n            <Button fx:id=\"commentModifyButton\" layoutX=\"27.0\" layoutY=\"17.0\" mnemonicParsing=\"false\" text=\"Modify\" />\n            <Button fx:id=\"commentDeleteButton\" layoutX=\"522.0\" layoutY=\"17.0\" mnemonicParsing=\"false\" text=\"Delete\" />\n            <Button fx:id=\"commentSaveButton\" layoutX=\"90.0\" layoutY=\"17.0\" mnemonicParsing=\"false\" prefHeight=\"25.0\" prefWidth=\"54.0\" text=\"Save\" />\n         </children>\n      </AnchorPane>\n   </children>\n</VBox>\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/resources/comment.fxml b/src/main/resources/comment.fxml
--- a/src/main/resources/comment.fxml	(revision 8bab4c89748eb1a7f8557f9361c3a1ce907e0f69)
+++ b/src/main/resources/comment.fxml	(date 1608481617913)
@@ -8,7 +8,7 @@
 <?import javafx.scene.layout.Pane?>
 <?import javafx.scene.layout.VBox?>
 
-<VBox maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefWidth="600.0" style="-fx-border-color: orange; -fx-border-radius: 10px; -fx-background-position: center; -fx-border-style: solid; -fx-border-image-width: 3px; -fx-background-color: white;" xmlns="http://javafx.com/javafx/11.0.1" xmlns:fx="http://javafx.com/fxml/1" fx:controller="it.unipi.dii.inginf.lsdb.justrecipe.controller.CommentController">
+<VBox fx:id="commentVBox" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefWidth="600.0" style="-fx-border-color: orange; -fx-border-radius: 10px; -fx-background-position: center; -fx-border-style: solid; -fx-border-image-width: 3px; -fx-background-color: white;" xmlns="http://javafx.com/javafx/11.0.1" xmlns:fx="http://javafx.com/fxml/1" fx:controller="it.unipi.dii.inginf.lsdb.justrecipe.controller.CommentController">
    <children>
       <AnchorPane prefHeight="41.0" prefWidth="600.0" VBox.vgrow="ALWAYS">
          <children>
Index: ../RecipeReader/src/main/java/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport com.google.gson.Gson;\nimport com.mongodb.client.*;\nimport org.bson.Document;\nimport org.neo4j.driver.*;\n\nimport java.io.IOException;\nimport java.nio.file.*;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static int HOW_MANY_RECIPES_TO_REMOVE = 30000;\n    public static String PATH_FULL_FORMAT_RECIPES = \"/home/fraie/Documenti/DatasetLSDB/full_format_recipes.json\";\n    public static String PATH_RECIPES_RAW_NOSOURCE_FN = \"/home/fraie/Documenti/DatasetLSDB/recipes_raw_nosource_fn.json\";\n\n    private static MongoClient mongoClient;\n    private static MongoDatabase database;\n    private static MongoCollection collection;\n    private static Driver driver;\n\n    public static void main (String[] arg)\n    {\n        mongoClient = MongoClients.create();\n        database = mongoClient.getDatabase(\"justrecipe\");\n        collection = database.getCollection(\"recipe\");\n\n        driver = GraphDatabase.driver( \"neo4j://localhost:7687\", AuthTokens.basic( \"neo4j\", \"justrecipe\" ) );\n\n        // First of all It is useful to remove the old values (if they exists)\n        // Just for re-execute the algorithm without problem\n        collection.drop();\n        deleteAllGraph();\n\n        List<RecipeRaw> rawRecipes = new ArrayList<>();\n        addRecipes_full_format(rawRecipes, PATH_FULL_FORMAT_RECIPES);\n        addRecipes_raw(rawRecipes, PATH_RECIPES_RAW_NOSOURCE_FN);\n\n        //I have removed the last HOW_MANY_RECIPES_TO_REMOVE recipes, that are the ones that have not so much information\n        rawRecipes.subList(rawRecipes.size() - HOW_MANY_RECIPES_TO_REMOVE, rawRecipes.size()).clear();\n\n        // Remove the recipe with title == null (filter (...)) and remove the duplicates (distinct())\n        List<RecipeRaw> recipesWithoutDuplicates = rawRecipes.stream().filter(new Predicate<RecipeRaw>() {\n            @Override\n            public boolean test(RecipeRaw recipeRaw) {\n                if (recipeRaw.getTitle() != null)\n                    return true;\n                return false;\n            }\n        }).distinct().collect(Collectors.toList());\n\n        // This reverse is used to insert the recipe with more information in the tail,\n        // so they will be the last insert\n        Collections.reverse(recipesWithoutDuplicates);\n\n        // List of users present at the initial time of the application\n        List<User> users = new ArrayList<>();\n        users.add(new User(\"Oliver\", \"Smith\", \"oliver.smith\", \"oliver.smith\"));\n        users.add(new User(\"Jack\", \"Jones\", \"jack.jones\", \"jack.jones\"));\n        users.add(new User(\"Harry\", \"Williams\", \"harry.williams\", \"harry.williams\"));\n        users.add(new User(\"Jacob\", \"Brown\", \"jacob.brown\", \"jacob.brown\"));\n        users.add(new User(\"Charlie\", \"Taylor\", \"charlie.taylor\", \"charlie.taylor\"));\n        users.add(new User(\"Thomas\", \"Davies\", \"thomas.davies\", \"thomas.davies\"));\n        users.add(new User(\"George\", \"Wilson\", \"george.wilson\", \"george.wilson\"));\n        users.add(new User(\"Oscar\", \"Evans\", \"oscar.evans\", \"oscar.evans\"));\n        users.add(new User(\"James\", \"Thomas\", \"james.thomas\", \"james.thomas\"));\n        users.add(new User(\"William\", \"Roberts\", \"william.roberts\", \"william.roberts\"));\n        users.add(new User(\"Amelia\", \"Murphy\", \"amelia.murphy\", \"amelia.murphy\"));\n        users.add(new User(\"Olivia\", \"Johnson\", \"olivia.johnson\", \"olivia.johnson\"));\n        users.add(new User(\"Isla\", \"Williams\", \"isla.williams\", \"isla.williams\"));\n        users.add(new User(\"Emily\", \"Walsh\", \"emily.walsh\", \"emily.walsh\"));\n        users.add(new User(\"Poppy\", \"Taylor\", \"poppy.taylor\", \"poppy.taylor\"));\n        users.add(new User(\"Ava\", \"Miller\", \"ava.miller\", \"ava.miller\"));\n        users.add(new User(\"Isabella\", \"Byrne\", \"isabella.byrne\", \"isabella.byrne\"));\n        users.add(new User(\"Jessica\", \"Evans\", \"jessica.evans\", \"jessica.evans\"));\n        users.add(new User(\"Lily\", \"Rodriguez\", \"lily.rodriguez\", \"lily.rodriguez\"));\n        users.add(new User(\"Sophie\", \"Roberts\", \"sophie.roberts\", \"sophie.roberts\"));\n\n        // First I insert the user, because when i choose randomly i can't be sure\n        // that they will be all pick-up, so i need to be sure that they are all present\n        // So, instead of adding the users in the insertRecipesAndUsers function, i have created another one function\n        addUsers(users);\n        insertRecipesOfUsers(recipesWithoutDuplicates, users);\n        \n        System.out.println(collection.countDocuments()); //How many documents loaded\n        mongoClient.close();\n        driver.close();\n    }\n\n    /**\n     * Add recipes from raw dataset\n     * @param recipes\n     * @param path\n     */\n    public static void addRecipes_raw (List<RecipeRaw> recipes, String path)\n    {\n        Gson gson = new Gson();\n        JsonFactory factory = new JsonFactory();\n        ObjectMapper mapper = new ObjectMapper(factory);\n        JsonNode rootNode = null;\n        try {\n            rootNode = mapper.readTree(Files.readAllBytes(Paths.get(path)));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        Iterator<Map.Entry<String,JsonNode>> fieldsIterator = rootNode.fields();\n        while (fieldsIterator.hasNext()) {\n            Map.Entry<String,JsonNode> field = fieldsIterator.next();\n            //The key is the unknow ID, the value is the recipe\n            recipes.add(gson.fromJson(field.getValue().toString(), RecipeRaw.class));\n        }\n    }\n\n    /**\n     * Add recipes from full_format dataset\n     * @param recipes\n     * @param path\n     */\n    public static void addRecipes_full_format (List<RecipeRaw> recipes, String path)\n    {\n        Gson gson = new Gson();\n        RecipeRaw[] recipeList = null;\n        StringBuilder contentBuilder = new StringBuilder();\n        try {\n            Files.lines(Paths.get(path)).forEach(s -> contentBuilder.append(s));\n            recipeList = gson.fromJson(contentBuilder.toString(), RecipeRaw[].class);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        Collections.addAll(recipes, recipeList);\n    }\n\n    /**\n     * Method that creates a new nodes in the graphDB with the information of the new users\n     * @param users      Users to add\n     */\n    public static void addUsers( final List<User> users)\n    {\n        Map<String,Object> params = new HashMap<>();\n        List<Map<String,Object>> list = new ArrayList<>();\n        for (User user: users)\n        {\n            Map<String,Object> props = new HashMap<>();\n            props.put( \"firstName\", user.getFirstName());\n            props.put( \"lastName\", user.getLastName());\n            props.put( \"username\", user.getUsername());\n            props.put( \"password\", user.getPassword());\n            list.add(props);\n        }\n        params.put( \"batch\", list );\n\n        try ( Session session = driver.session())\n        {\n            session.writeTransaction((TransactionWork<Void>) tx -> {\n                tx.run( \"UNWIND $batch AS row \" +\n                                \"MERGE (u:User {firstName: row.firstName, lastName: row.lastName, \" +\n                                \"username: row.username,\" +\n                                \"password: row.password, role:0})\",\n                        params);\n                return null;\n            });\n        }\n    }\n\n    /**\n     * Function that insert all the recipes, every one is associated at one user randomly picked\n     * @param recipeRaws    The list of the recipes\n     * @param users         The list of the users\n     */\n    public static void insertRecipesOfUsers (List<RecipeRaw> recipeRaws, List<User> users)\n    {\n        List<Document> documents = new ArrayList<Document>();\n        Date date = new Date();\n        Map<String,Object> params = new HashMap<>();\n        List<Map<String,Object>> list = new ArrayList<>();\n        Random random = new Random();\n        int i= 0;\n        for (RecipeRaw rawRecipe: recipeRaws) // For every recipe\n        {\n            // pick-up randomly a user to associate with this recipe\n            int userIndex = random.nextInt(users.size()); //[0,19]\n            User user = users.get(userIndex);\n\n            // MongoDB part\n            String title = rawRecipe.getTitle();\n            Document doc = new Document(\"title\", title);\n            if (rawRecipe.getInstructions() != null)\n            {\n                doc.append(\"instructions\", rawRecipe.getInstructions());\n            }\n            else if (rawRecipe.getDirections() != null) // this recipe has the directions\n            {\n                String instructions = \"\";\n                for (String s : rawRecipe.getDirections())\n                {\n                    instructions += s + \"\\n\";\n                }\n                doc.append(\"instructions\", instructions);\n            }\n            if (rawRecipe.getIngredients() != null)\n                doc.append(\"ingredients\", rawRecipe.getIngredients());\n            if (rawRecipe.getCategories() != null)\n                doc.append(\"categories\", rawRecipe.getCategories());\n            if (rawRecipe.getCalories() != 0)\n                doc.append(\"calories\", rawRecipe.getCalories());\n            if (rawRecipe.getFat() != 0)\n                doc.append(\"fat\", rawRecipe.getFat());\n            if (rawRecipe.getProtein() != 0)\n                doc.append(\"protein\", rawRecipe.getProtein());\n            if (rawRecipe.getCarbs() != 0)\n                doc.append(\"carbs\", rawRecipe.getCarbs());\n            // For the timestamp MongoDB use the \"Date\"\n            doc.append(\"creationTime\", new Date(date.getTime()+(1000*i)));\n            doc.append(\"authorUsername\", user.getUsername());\n            documents.add(doc);\n\n            // Neo4j part\n            Map<String,Object> props = new HashMap<>();\n            props.put( \"username\", user.getUsername());\n            props.put(\"timestamp\", new Date(date.getTime()+(1000*i)).getTime());\n            props.put(\"title\", rawRecipe.getTitle());\n            if (rawRecipe.getCalories() != 0)\n                props.put(\"calories\", rawRecipe.getCalories());\n            if (rawRecipe.getFat() != 0)\n                props.put(\"fat\", rawRecipe.getFat());\n            if (rawRecipe.getProtein() != 0)\n                props.put(\"protein\", rawRecipe.getProtein());\n            if (rawRecipe.getCarbs() != 0)\n                props.put(\"carbs\", rawRecipe.getCarbs());\n            list.add(props);\n\n            i++;\n        }\n\n        // Mongo insert\n        collection.insertMany(documents);\n\n        // Neo4j insert\n        params.put( \"batch\", list );\n        try ( Session session = driver.session())\n        {\n            session.writeTransaction((TransactionWork<Void>) tx -> {\n                // First step: find the right user\n                // Second step: create the path ADDS and the recipe\n                tx.run( \"UNWIND $batch AS row \" +\n                                \"MATCH (u:User {username: row.username}) \" +\n                                \"CREATE (u)-[:ADDS {when: row.timestamp}]->(r:Recipe {title: row.title, calories: row.calories, \" +\n                                \"fat: row.fat, protein: row.protein, carbs: row.carbs})\",\n                        params);\n                return null;\n            });\n        }\n    }\n\n    /**\n     * Function used to delete all the nodes and the edges of the graph\n     */\n    public static void deleteAllGraph ()\n    {\n        try ( Session session = driver.session())\n        {\n            session.writeTransaction((TransactionWork<Void>) tx -> {\n                tx.run( \"MATCH (n) DETACH DELETE n\");\n                return null;\n            });\n        }\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../RecipeReader/src/main/java/Main.java b/../RecipeReader/src/main/java/Main.java
--- a/../RecipeReader/src/main/java/Main.java	(revision 8bab4c89748eb1a7f8557f9361c3a1ce907e0f69)
+++ b/../RecipeReader/src/main/java/Main.java	(date 1608481617920)
@@ -13,8 +13,8 @@
 
 public class Main {
     public static int HOW_MANY_RECIPES_TO_REMOVE = 30000;
-    public static String PATH_FULL_FORMAT_RECIPES = "/home/fraie/Documenti/DatasetLSDB/full_format_recipes.json";
-    public static String PATH_RECIPES_RAW_NOSOURCE_FN = "/home/fraie/Documenti/DatasetLSDB/recipes_raw_nosource_fn.json";
+    public static String PATH_FULL_FORMAT_RECIPES = "/home/francesco/Scaricati/full_format_recipes/full_format_recipes.json";
+    public static String PATH_RECIPES_RAW_NOSOURCE_FN = "/home/francesco/Scaricati/recipes_raw/recipes_raw_nosource_fn.json";
 
     private static MongoClient mongoClient;
     private static MongoDatabase database;
